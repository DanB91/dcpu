// This file is subject to a 1-clause BSD license.
// Its contents can be found in the enclosed LICENSE file.

// This package implements a DCPU code profiler.
package prof

import "fmt"
import "github.com/jteeuwen/dcpu/cpu"

// Cycle counts per opcode.
var opcodes = [...]uint8{
	// Basic opcodes
	0, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1,
	2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 0, 0, 2, 2,

	// Extended opcodes.
	0, 2, 0, 0, 0, 0, 0, 0, 4, 1, 1, 3, 2, 0, 0, 0,
	2, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
}

// Cycle counts per operand.
var operands = [...]uint8{
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1,
}

// A Profile holds timing and execution information for a single test program.
type Profile struct {
	Files []string // List of source files associated with program.

	// Profile data per instruction.
	//
	// This stores a ProfileData instance for every PC value we encounter.
	// It may therefor contain multiple structures for the same opcode.
	Data []*ProfileData
}

// New creates a new, empty profile.
//
// For best results, it requires source information from a debug context
// which is generated by our assembler.
func New(sourcefiles []string, codelen int) *Profile {
	p := new(Profile)
	p.Files = sourcefiles
	p.Data = make([]*ProfileData, codelen)
	return p
}

// Update updates the instruction information for each instruction as it
// is executed.
//
// For best results, it requires source information from a debug context
// which is generated by our assembler.
func (p *Profile) Update(pc, op, a, b, av, bv cpu.Word, file, line, col int) {
	pd := p.Data[pc]

	if pd == nil {
		pd = new(ProfileData)
		pd.Opcode = op
		pd.A = a
		pd.B = b
		pd.File = file
		pd.Line = line
		pd.Col = col
		pd.Penalty = 0
		pd.AValue = av
		pd.BValue = bv
		p.Data[pc] = pd
	}

	pd.Count++
}

// UpdateCost alters the cumulative cost of a given instruction where necessary.
// This can happen when a branching instruction failed its check and had to
// be skipped. This increases its cost.
func (p *Profile) UpdateCost(pc, cost cpu.Word) {
	p.Data[pc].Penalty += uint64(cost)
}

// CountUses counts the number of instructions we have actually seen
// being used during the profiling session.
func (p *Profile) CountUses() int {
	var c int

	for _, v := range p.Data {
		if v != nil {
			c++
		}
	}

	return c
}

// DataForFunctions returns all recorded ProfileData structures for
// function calls. This fetches all data for the JSR instruction and merges
// nodes which target the same label address. So that we have only one
// entry for every unique function.
func (p *Profile) DataForFunctions() SampleList {
	tmp := p.DataForOpcode(cpu.JSR, true)
	if len(tmp) == 0 {
		return nil
	}

	var list SampleList
	for i := range tmp {
		fmt.Printf("%04x\n", tmp[i].Data.BValue)
	}

	return list
}

// DataForOpcode returns all recorded ProfileData structures for the given opcode.
func (p *Profile) DataForOpcode(opcode cpu.Word, isExtended bool) SampleList {
	var list SampleList

	for i, v := range p.Data {
		if v == nil {
			continue
		}

		if isExtended {
			if v.Opcode == cpu.EXT && v.A == opcode {
				list = append(list, Sample{PC: cpu.Word(i), Data: v})
			}
			continue
		} else if v.Opcode == opcode {
			list = append(list, Sample{PC: cpu.Word(i), Data: v})
		}
	}

	return list
}

// DataForFile returns all recorded ProfileData structures for the given file.
func (p *Profile) DataForFile(fileindex int) SampleList {
	var list SampleList

	for i, v := range p.Data {
		if v != nil && v.File == fileindex {
			list = append(list, Sample{PC: cpu.Word(i), Data: v})
		}
	}

	return list
}
