// This file is subject to a 1-clause BSD license.
// Its contents can be found in the enclosed LICENSE file.

// This package implements a DCPU code profiler.
package prof

import "github.com/jteeuwen/dcpu/cpu"

// Cycle counts per opcode.
var opcodes = [...]uint8{
	// Basic opcodes
	0, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1,
	2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 0, 0, 2, 2,

	// Extended opcodes.
	0, 2, 0, 0, 0, 0, 0, 0, 4, 1, 1, 3, 2, 0, 0, 0,
	2, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
}

// Cycle counts per operand.
var operands = [...]uint8{
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1,
}

// A Profile holds timing and execution information for a single test program.
type Profile struct {
	Files []string // List of source files associated with program.

	// Usage data per instruction.
	//
	// This stores a ProfileData instance for every PC value we encounter.
	// It may therefor contain multiple structures for the same opcode.
	Usage []*ProfileData
}

// New creates a new, empty profile.
//
// For best results, it requires source information from a debug context
// which is generated by our assembler.
func New(sourcefiles []string, codelen int) *Profile {
	p := new(Profile)
	p.Files = sourcefiles
	p.Usage = make([]*ProfileData, codelen)
	return p
}

// Update updates the instruction information for each instruction as it
// is executed.
//
// For best results, it requires source information from a debug context
// which is generated by our assembler.
func (p *Profile) Update(pc, op, a, b cpu.Word, file, line, col int) {
	pd := p.Usage[pc]

	if pd == nil {
		pd = new(ProfileData)
		pd.Opcode = op
		pd.A = a
		pd.B = b
		pd.File = file
		pd.Line = line
		pd.Col = col
		p.Usage[pc] = pd
	}

	pd.Count++
}

// CountUses counts the number of instructions we have actually seen
// being used during the profiling session.
func (p *Profile) CountUses() int {
	var c int

	for _, v := range p.Usage {
		if v != nil {
			c++
		}
	}

	return c
}

// DataForOpcode returns all recorded ProfileData structures for the given opcode.
func (p *Profile) DataForOpcode(opcode cpu.Word) []*ProfileData {
	var list []*ProfileData

	for _, v := range p.Usage {
		if v != nil && v.Opcode == opcode {
			list = append(list, v)
		}
	}

	return list
}

// DataForFile returns all recorded ProfileData structures for the given file.
func (p *Profile) DataForFile(fileindex int) []*ProfileData {
	var list []*ProfileData

	for _, v := range p.Usage {
		if v != nil && v.File == fileindex {
			list = append(list, v)
		}
	}

	return list
}
