## DCPU Profiler

**Note**: This is work in progress. I hope to expand the amount of data about
a program one can query along with ways to make it more useful.

This is an interactive commandline tool that can analyze profiling data
generated by the `prof` package.

It accepts a number of textual commands which serve to display various
types of data in table form. Options to these commands allow us to
sort the data in different ways and to filter out unnecessary clutter.


## Known issues

The profiling mode for functions is flaky at best because it makes some
assumptions about code layout which will not be true in all situations.

One of the assumptions is that address references in a JSR instruction can
not be null (0). This is done to prevent the profiler from interpreting data
sections as code and mistaking some data for a valid jump. This is not
100% fool-proof, but it works for the majority of cases.

Additionally, it assumes functions will always return by means of 
an unconditional `SET PC, POP` instruction. It also assumes this return is
physically the last instruction in the function. Jumping over it to more code
would be problematic.

One example of this can be seen in `lib/string/memmove.dasm` at line 36. As far
as the profiler is concerned, that line is the end of the `memmove` function,
eventhough it clearly isn't. The consequence of this is that the count and
cycle cost values for the `memmove` fuction are incorrect.

A solution could be to reorganize the branching statements to make the return
a part of it, but this is not necessarily an efficient solution when one
considers the overhead that failed branch checks can incur.

If your code contains a lot of these cases, it is advised to only use
the file mode listings in this profiler, since it makes no such assumptions.


### Usage

Read the given file:

    $ dcpu-prof data.prof

Type 'help' in the program for a list of commands.


### Top Example

Here is an excerpt of an example usage of the `top` command.
It lists only the usage of functions or files. This is a good starting point
when profiling code. As it gives a rough overview of where most of the CPU
time is spent without going into too much detail.

	top
	48 sample(s), 110 cycle(s)
		   42  87.50%       98  89.09% memchr               memchr.dasm:15
		    4   8.33%        8   7.27% assert_eq            assert_eq.dasm:8
		    2   4.17%        4   3.64% assert_ez            assert_ez.dasm:8

	top -file
	108 sample(s), 225 cycle(s)
		   70  64.81%      157  69.78% memcmp.dasm
		   28  25.93%       48  21.33% _test.dasm
		    8   7.41%       16   7.11% assert_eq.dasm
		    2   1.85%        4   1.78% assert_ez.dasm


The table shows 5 or 6 columns, depending on whether you are viewing
function or file listings:

* **COUNT**: This is the cumulative total number of times each instruction
  inside this function was executed.

* **COUNT PERC**: This is the percentage of the total count for all
  returned samples.
  
* **COST**: This is the cumulative cycle cost for all instructions inside
  this function.
  
* **COST PERC**: This is the cost percentage of the total cost for the
  returned samples.
  
* **NAME**: This is the name of the function, denoted by the label that
  directly preceeded its definition.
  
* **FILE**: This shows the original source file and line in which the
  function is defined.


### List Example

Here is an example of the `list` command output:

	list
	===> lib/string/memchr.dasm 15-29
	42 sample(s), 98 cycle(s)

		   3       11   015:   ife 0, c ; num is zero -- No compare needed.
		   1        1   016:     set pc, pop
		                017: 
		                018: :memchr_loop
		   8       23   019:   ife [a], b
		   1        1   020:     set pc, pop
		   7       14   021:   sub c, 1
		   7       20   022:   ife c, 0
		   1        2   023:     set pc, memchr_ret
		   6       12   024:   add a, 1
		   6       12   025:   set pc ,memchr_loop
		                026: 
		                027: :memchr_ret
		   1        1   028:   set a, 0
		   1        1   029:   set pc, pop

	===> lib/test/assert_eq.dasm 8-10
	4 sample(s), 8 cycle(s)

		   2        6   008:   ifn a, b
		                009:     panic assert_eq_str
		   2        2   010:   set pc, pop

	===> lib/test/assert_ez.dasm 8-10
	2 sample(s), 4 cycle(s)

		   1        3   008:   ifn a, 0
		                009:     panic assert_ez_str
		   1        1   010:   set pc, pop



It lists the sources for all functions that match the filter specified in
the command. Using `list` without a filter, defaults to showing all function
sources. This display comes with the original source code, along with some
extra data in the first two columns:

* **COUNT**: This is the total number of times the instruction was executed.
  
* **COST**: This is the total cycle cost for this instruction.
  
The output of this command without a filter can be overwhelming in a large
codebase, so it is practical to use it in combination with `top`. Use `top`
to find a function or file that consumes the most cycles and then dive into
the detailed usage with `list`:

	list -f memchr
	===> lib/string/memchr.dasm 15-29
	42 sample(s), 98 cycle(s)
	
	...


As with `top`, we can specify the `-file` flag in this command to list
full file contents, instead of just specific functions. This is useful for
code where no function calls are used.


### Dependencies

* github.com/jteeuwen/dcpu/cpu
* github.com/jteeuwen/dcpu/prof
* github.com/jteeuwen/dcpu/parser


### License

DCPU, 0x10c and related materials are Copyright 2012 Mojang.

Unless otherwise stated, all of the work in this project is subject to a
1-clause BSD license. Its contents can be found in the enclosed LICENSE file.
